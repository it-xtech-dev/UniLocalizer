using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace UniLocalizer
{

    /// <summary>
    /// Provides localizer json resource provider.
    /// </summary>
    public class UniLocalizerBaseProvider
    {
        internal string resourceRootPath;
        internal UniLocalizerOptions options;
        internal IMemoryCache cache;

        /// <summary>
        /// Creates new instance of provider class.
        /// </summary>
        /// <param name="options">The options</param>
        public UniLocalizerBaseProvider(IOptions<UniLocalizerOptions> options, IMemoryCache cache)
        {
            this.options = options.Value;
            this.resourceRootPath = options.Value.ResourcesPath;
            this.cache = cache;
            //this.LoadResources(this.resourceRootPath);
        }

        /// <summary>
        /// Clears  all resources form files.
        /// </summary>
        internal void Clear()
        {
            this.ItemList.Clear();
            this.LoadedFiles.Clear();
            //this.LoadResources(this.resourceRootPath);
        }

        /// <summary>
        /// Gets list of currently loaded resource items (translation tokens).
        /// </summary>
        public Dictionary<string, ResourceItem> ItemList { get; } = new Dictionary<string, ResourceItem>();

        /// <summary>
        /// Gets list of currently loaded files.
        /// </summary>
        public Dictionary<string, ResourceFile> LoadedFiles { get; } = new Dictionary<string, ResourceFile>();

        /// <summary>
        /// Gets localized string for given culture, resource file locatio and resource key.
        /// </summary>
        /// <param name="culture">The culture.</param>
        /// <param name="resourceLocation">The resouce file location (root relative) ex: path1.path2.fileName </param>
        /// <param name="resourceKey">The resouce key</param>
        /// <returns>Localized string</returns>
        public string Get(CultureInfo culture, string resourceLocation, string resourceKey)
        {
            return InternalGet(culture, resourceLocation, resourceKey);
        }

        /// <summary>
        /// Gets localized string for given general key
        /// </summary>
        /// <param name="generalKey">General key containg of culture, resource file location and resource key. ex: en-US:.data/file1:My_Key </param>
        /// <returns>Localized string</returns>
        public string Get(string generalKey)
        {
            return InternalGet(generalKey);
        }

        /// <summary>
        /// Gets collection of localized strings for given culture.
        /// </summary>
        /// <param name="culture">The culture.</param>
        /// <returns>Dictionary of key / value localized strings.</returns>
        public Dictionary<string, string> Get(CultureInfo culture)
        {
            return InternalGet(culture);
        }

        /// <summary>
        /// Gets collection of localized strings for given culture.
        /// <param name="culture">The culture</param>
        /// <returns>NotImplementedException</returns>
        private Dictionary<string,string> InternalGet(CultureInfo culture)
        {

            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets localized string for given general key.
        /// </summary>
        /// <param name="generalKey">General key containg of culture, resource file location and resource key. ex: en-US:.data/file1:My_Key </param>
        /// <returns>Localized string when found or missing/autogenerated text</returns>
        private string InternalGet(string generalKey)
        {
            var localizedString = this.ItemList.GetValue(generalKey.GetHashString())?.Value;
            const string AUTO_GEN = "#AUTOGENERATED";

            var keys = generalKey.Split(':');
            var culture = new CultureInfo(keys[0]);
            var resourceLocationKey = keys[1];
            var resourceFileGeneralKey = culture + ":" + resourceLocationKey + ":";
            var itemKey = keys[2];

            if (localizedString == null && options.AutogenerateMissingKeys && options.IsTranslatorEnabled)
            {
                var fileKeyHash = ResourceFile.GetKeyHash(resourceFileGeneralKey);
                if (!this.LoadedFiles.TryGetValue(fileKeyHash, out var file))
                {
                    // it seems that file for this token does not exits
                    // we have to add it manuall - file will be saved on users demand
                    var maxFileIndex = this.LoadedFiles.Values.Max(f => f.Index);
                    // file content will be generated later;
                    file = new ResourceFile(maxFileIndex + 1, resourceFileGeneralKey, "");
                    
                    // TODO: use Logger to log when add was unsuccessfull.
                    // There might be some issues realted to multithreading.
                    this.LoadedFiles.TryAdd(fileKeyHash, file);
                }
                var item = new ResourceItem(culture, resourceLocationKey, itemKey, null, file);
                // trigger resource modification for change tracking.
                item.Value = AUTO_GEN;
                localizedString = item.Value;
                // TODO: use Logger to log when add was unsuccessfull.
                // There might be some issues realted to multithreading.
                this.Add(item);
            }
            if (localizedString == null)
            {
                return "#MISS:" + (this.options.DisplayShortNotation ?  itemKey : generalKey);
            }
            if (localizedString == "#AUTOGENERATED")
            {
                return "#AUTO" + ":" + (this.options.DisplayShortNotation ? itemKey : generalKey);
            }

            return localizedString;
        }


        /// <summary>
        /// Gets localized string for given culture, resouce file location key and resource key.
        /// </summary>
        /// <param name="culture">The culture</param>
        /// <param name="resourceLocationKey">The resouce location key, ex: .data.fileName </param>
        /// <param name="itemKey">The resource key.</param>
        /// <returns></returns>
        private string InternalGet(CultureInfo culture, string resourceLocationKey, string itemKey)
        {
            string generalKey = culture.Name + ":" + resourceLocationKey + ":" + itemKey;
            return this.InternalGet(generalKey);
        }


        /// <summary>
        /// Adds new resource item to memory cache.
        /// </summary>
        /// <param name="item">The resource item</param>
        public bool Add(ResourceItem item)
        {
            item.OnModification += (sender, eventArgs) =>
            {
                var cacheFileItemKey = $"Localizer_File_{item.File.Index}";
                var tokenSource = this.cache.Get<CancellationTokenSource>(cacheFileItemKey);
                if (tokenSource != null)
                {
                    tokenSource.Cancel();
                    cache.Remove(cacheFileItemKey);
                }
            };
            return this.ItemList.TryAdd(item.GeneralKey.GetHashString(), item);
        }

        /// <summary>
        /// Refreshes resource file content according to current ResourceItems state.
        /// </summary>
        /// <param name="file">The resource file object</param>
        public void RefreshResourceFile(ResourceFile file)
        {
            var fileKey = file.Key;
            var resourceItems = this.ItemList.Where(i => i.Value.GeneralKey.StartsWith(fileKey));
            var resourceItemsDictionary = resourceItems.OrderBy(i => i.Value.Key).ToDictionary(i => i.Value.Key, i => i.Value.Value);
            var json = JsonConvert.SerializeObject(resourceItemsDictionary, Formatting.Indented);
            file.Content = json;

            file.IsSynced = true;
        }
    }
}
